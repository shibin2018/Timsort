#include<stdio.h>
#include<math.h>
#include<stdlib.h>
#include<time.h>
#include<assert.h>
#include<string.h>


#define innode 5
#define hidenode 16
#define outnode 1
#define alpha 0.1
#define binary_dim 10
#define row 6
#define column 10000

#define randval(high) ( (double)rand() / RAND_MAX * high )

double sigmoid(double);

double w[innode][hidenode]= {-0.50544,-0.190164,0.0238119,-0.0419997,0.947117,-0.0611519,0.0908817,-1.31198,-0.359938,-0.197944,0.136735,-0.614922,1.15036,-0.333292,-0.644524,-1.11594,
                             -0.943105,0.020098,-0.534987,0.830981,-0.191964,-0.0233846,1.16714,-1.53667,-0.0723691,0.430915,0.295803,0.0164728,-0.457005,-0.333249,0.327001,-1.33272,
                             0.783645,0.845658,0.019408,-0.20531,0.432115,-0.206258,-0.415846,-0.449112,0.657304,-0.0084984,0.411634,0.439167,0.530898,0.143333,-0.953089,0.207835,
                             -0.821714,-0.184718,-0.431293,0.536812,0.991263,0.0561813,0.0531322,0.0954561,-1.83292,0.620908,-1.09436,0.0164753,0.190277,0.174549,-0.689823,0.622499,
                             -1.52908,1.57299,-0.341168,0.515654,-0.240618,-1.6251,-1.43245,1.10243,0.902757,-1.0397,-0.291358,0.486522,-1.91308,-1.65619,-0.96906,-0.605805
                            };
double w1[hidenode][outnode]= {2.85927,-0.84181,2.91807,-2.23612,-1.78549,1.77253,2.51113,
                               -1.47216,-0.748953,1.90782,-0.392718,-2.16234,1.63118,2.60154,0.809072,-0.271197
                              };
double wh[hidenode][hidenode]= {0.480621,-0.334035,-0.468351,0.510464,-1.00154,0.726049,0.831713,-0.59545,0.921675,1.08879,-0.475592,-0.0881216,0.538322,-0.221457,0.453245,-0.683392,
                                0.754759,-0.75533,0.10441,-1.10602,-0.619167,-0.368404,0.04019,0.433887,0.575279,-0.754628,0.350746,0.795816,-0.0340984,-0.443617,0.837579,-0.815285,
                                0.478606,0.0246975,0.431921,-0.18438,-0.913553,-0.278118,0.295259,-0.924258,0.157895,0.439898,0.52019,-0.382457,0.637347,-0.46058,-0.282024,-0.455176,
                                -0.0904853,-0.26641,-0.207466,0.572693,0.673072,-0.340627,-0.301959,0.414407,-0.846757,0.676599,-0.545579,0.463913,0.0695779,-0.223701,0.724119,0.429477,
                                -0.25113,-0.781648,-0.220843,0.00305416,0.438732,-0.686582,0.728238,0.736752,-0.295294,1.08925,0.901036,0.0964353,-0.0798263,-0.330321,-1.12689,-0.335095,
                                0.259687,-0.983603,0.357227,0.619784,0.775478,0.340881,0.593681,-0.118247,0.251638,-0.365559,0.520251,0.257208,-0.470738,-0.909186,0.430442,0.458128,
                                0.51896,0.480833,0.241369,0.738382,0.230506,0.638418,0.431298,-0.0652254,0.802607,0.950213,-0.859131,-0.85191,0.573261,-0.690661,0.260387,0.604141,
                                -0.29852,0.663724,-0.238589,0.306494,-0.17962,0.613134,0.55585,-0.462257,-0.309266,-0.89714,0.451543,-0.150042,-1.15802,0.0660016,0.171007,0.181963,
                                -0.971799,-0.482196,0.312881,-1.00479,0.110727,0.47896,0.736038,0.956644,-0.859408,-0.89795,0.973085,0.648027,-0.769698,0.769366,-1.21644,-0.878893,
                                0.530118,0.054148,-1.0729,-0.201676,0.608916,-0.699246,0.428427,-1.06804,-0.402471,0.695456,0.867219,0.321473,0.87579,-0.0245224,0.245934,-0.808639,
                                0.456247,0.812384,-1.08356,-0.291636,0.454986,0.0674999,-0.412951,-0.228577,0.957102,0.435722,0.0121875,1.09174,-0.723763,0.425298,-0.498239,0.873796,
                                0.284028,0.512408,0.423821,1.10557,-0.986569,0.455406,-0.00785105,0.830526,0.605241,-0.375948,-0.216552,0.302655,0.224033,-0.547061,0.00334776,-0.290342,
                                0.219295,0.54882,0.548845,0.190067,-0.472564,-0.179992,1.26061,-0.266396,0.306558,-0.263702,0.478618,0.258131,-0.779555,0.810126,-1.03249,-1.12167,
                                0.494687,-1.03418,-0.0543446,0.420793,-0.0713128,0.359502,-0.901753,0.249053,-0.95026,-0.803257,-0.170956,-0.386359,0.920871,-0.1966,-0.673016,0.0167744,
                                1.15777,-0.223283,0.329325,-0.108584,-0.114493,0.300977,-0.218649,-0.0509054,0.749849,-0.452297,0.91572,-0.728414,-0.885534,-0.722841,-0.933356,0.0890621,
                                -0.586933,1.00569,0.281663,-0.201912,-0.487541,0.515948,-0.20535,0.445551,-0.508886,0.379399,-0.104594,0.657253,-1.02111,0.236524,0.47607,0.576467
                               };
void train_test();
float DATA[row][column];
int main() {
//将数据读入数组a
	char str[1000000];
	FILE* fp=fopen("./PID-1.csv","r"); //打开文件
	if(fp==NULL) {
		printf("Error");
		return -1;
	}
	int i;
	for(i=0; i<row; i++) {
		//printf("good!");
		fscanf(fp,"%s",&str);//*每次读取一个数，fscanf函数遇到空格或者换行结束*/
		char *p;
		p=strtok(str,",");
		int j=0;
		while(p) {
			//printf("%s ",p);
			DATA[i][j]=atof(p);
			//	printf("%d %d %.2f ",i,j,a[i][j]);
			p=strtok(NULL,",");
			j++;
			if(j>column)
				break;
		}
//		printf("\n");
	}
	fclose(fp);
//读入数据完毕
	printf("Input data completed!");
	train_test();
	return 0;
}

double sigmoid(double x) {
	return 1.0/(1.0+exp(-x));
}

void train_test() {
	int group,list,l,i,p,j,m,k,q;
	for (group=0; group<100; group++) {
		FILE *fw;
		fw=fopen("./result.txt","a+");
		for (list=0; list<binary_dim; list++) {
			double d[binary_dim];                    //保存每次生成的预测值

			double a[binary_dim];
			double b[binary_dim];
			double f[binary_dim];
			double g[binary_dim];
			double h[binary_dim];

			double c[binary_dim];//保存正确值
			for (l=0; l<binary_dim; l++) {
				a[l]=DATA[1][group*100+list*binary_dim+l];
				b[l]=DATA[2][group*100+list*binary_dim+l];
				f[l]=DATA[3][group*100+list*binary_dim+l];
				g[l]=DATA[4][group*100+list*binary_dim+l];
				h[l]=DATA[5][group*100+list*binary_dim+l];

				c[l]=DATA[0][group*100+list*binary_dim+l]; //真实的和 c

			}
			double layer_0[innode];
			double layer_2[outnode];
			double layer_1[hidenode];         //隐藏层
			double layer_11[hidenode];        //存储上一次隐藏层的值
			for( i=0; i<hidenode; i++)         //在0时刻是没有之前的隐含层的，所以初始化一个全为0的
				layer_11[i] = 0;
			//正向传播
			for( p=0; p<binary_dim; p++) {         //循环遍历二进制数组，从最低位开始
				layer_0[0] = a[p];
				layer_0[1] = b[p];
				layer_0[2] = f[p];
				layer_0[3] = g[p];
				layer_0[4] = h[p];

				double y = (double)c[p];          //实际值

				for( j=0; j<hidenode; j++) {
					//输入层传播到隐含层
					double o1 = 0.0;
					for(m=0; m<innode; m++)
						o1 += layer_0[m] * w[m][j];
					//之前的隐含层传播到现在的隐含层
					for(m=0; m<hidenode; m++)
						o1 += layer_11[m] * wh[m][j];

					layer_1[j] = sigmoid(o1);      //隐藏层各单元输出
				}
				for( k=0; k<outnode; k++) {
					//隐藏层传播到输出层
					double o2 = 0.0;
					for(j=0; j<hidenode; j++)
						o2 += layer_1[j] * w1[j][k];
					layer_2[k] = sigmoid(o2);          //输出层各单元输出
				}
				for(q=0; q<hidenode; q++)
					layer_11[q]=layer_1[q];
				d[p] = layer_2[0];   //记录预测值

			}
			printf("Group:  %d, List: %d\n",group,list);
			printf("pred: ");

			for(k=0; k<binary_dim; k++)
				printf("%f  ",d[k]);
			printf("\n");
			printf("true: ");
			for(k=0; k<binary_dim; k++)
				printf("%f  ",c[k]);
			printf("\n");	
			for (k=0;k<binary_dim;k++){
			fprintf(fw,"%f",d[k]*8395.5040-593.0405);
			fprintf(fw,",");
			}			   	
		}
		fprintf(fw,"\n");
		fclose(fw);
	}
}







